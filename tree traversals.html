<!doctype html>
<html lang="en" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BST Traversal Visualizer</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #87CEEB;
      color: #2C3E50;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    html {
      height: 100%;
      width: 100%;
    }

    * {
      box-sizing: border-box;
    }

    .main-container {
      display: flex;
      width: 100%;
      height: 100%;
      background: #87CEEB;
    }

    .left-panel {
      width: 30%;
      background: #FFFFFF;
      padding: 20px;
      overflow-y: auto;
      box-shadow: 3px 0 15px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .right-panel {
      width: 70%;
      background: #87CEEB;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 26px;
      color: #2E7D32;
      text-align: center;
      font-weight: 700;
    }

    .section {
      background: #FAFAFA;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      border: 1px solid #E8E8E8;
    }

    .section-title {
      font-size: 16px;
      font-weight: bold;
      color: #2E7D32;
      margin-bottom: 12px;
      border-bottom: 3px solid #66BB6A;
      padding-bottom: 6px;
    }

    .input-group {
      margin-bottom: 10px;
    }

    .input-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: #424242;
      margin-bottom: 6px;
    }

    input[type="text"] {
      width: 100%;
      padding: 11px;
      border: 2px solid #81C784;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
    }

    .btn {
      padding: 11px 18px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      margin: 5px 5px 5px 0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.18);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-build {
      width: 100%;
      background: linear-gradient(135deg, #66BB6A 0%, #4CAF50 100%);
      color: white;
      font-size: 16px;
      padding: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-build:hover:not(:disabled) {
      background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
    }

    .btn-control {
      width: calc(50% - 5px);
      background: linear-gradient(135deg, #81C784 0%, #66BB6A 100%);
      color: white;
    }

    .btn-control:hover:not(:disabled) {
      background: linear-gradient(135deg, #66BB6A 0%, #4CAF50 100%);
    }

    .btn-control.pause {
      background: linear-gradient(135deg, #FFB74D 0%, #FFA726 100%);
    }

    .btn-control.pause:hover:not(:disabled) {
      background: linear-gradient(135deg, #FFA726 0%, #FF9800 100%);
    }

    .btn-control.reset {
      background: linear-gradient(135deg, #E57373 0%, #EF5350 100%);
    }

    .btn-control.reset:hover:not(:disabled) {
      background: linear-gradient(135deg, #EF5350 0%, #F44336 100%);
    }

    .btn-traversal {
      width: calc(50% - 5px);
      background: linear-gradient(135deg, #9575CD 0%, #7E57C2 100%);
      color: white;
    }

    .btn-traversal:hover:not(:disabled) {
      background: linear-gradient(135deg, #7E57C2 0%, #673AB7 100%);
    }

    .btn-traversal.active {
      background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
      border: 3px solid #FFD700;
      transform: scale(1.02);
    }

    .comparison-box {
      background: linear-gradient(135deg, #FFF9E6 0%, #FFF3CD 100%);
      border: 3px solid #FFC107;
      border-radius: 12px;
      padding: 16px;
      margin-top: 12px;
      min-height: 90px;
      font-size: 14px;
      line-height: 1.7;
      box-shadow: 0 3px 10px rgba(255, 193, 7, 0.2);
    }

    .comparison-box .question {
      font-weight: bold;
      color: #E65100;
      font-size: 16px;
      margin-bottom: 6px;
    }

    .comparison-box .answer {
      color: #1976D2;
      font-weight: 600;
      font-size: 15px;
    }

    .comparison-box .decision {
      color: #2E7D32;
      font-weight: 600;
      margin-top: 6px;
      font-size: 15px;
    }

    .algorithm-steps {
      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
      border-radius: 10px;
      padding: 12px;
    }

    .step-item {
      padding: 11px 13px;
      margin: 6px 0;
      border-radius: 8px;
      background: white;
      border-left: 4px solid #81C784;
      transition: all 0.3s ease;
      font-size: 13px;
      color: #424242;
    }

    .step-item.active {
      background: linear-gradient(135deg, #FFD54F 0%, #FFCA28 100%);
      border-left-color: #F57F17;
      font-weight: bold;
      transform: scale(1.03);
      box-shadow: 0 3px 12px rgba(255, 202, 40, 0.4);
      color: #1a1a1a;
    }

    .traversal-rule-box {
      background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
      border-radius: 12px;
      padding: 18px;
      text-align: center;
      color: white;
      font-size: 19px;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.35);
    }

    .rule-part {
      display: inline-block;
      padding: 10px 18px;
      margin: 0 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.25);
      transition: all 0.3s ease;
      font-size: 17px;
    }

    .rule-part.active {
      background: #FFD700;
      color: #1a1a1a;
      transform: scale(1.2);
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.7);
    }

    .speed-control {
      margin-top: 12px;
    }

    .speed-slider {
      width: 100%;
      margin: 10px 0;
      height: 8px;
      border-radius: 5px;
      background: #C8E6C9;
      outline: none;
    }

    .speed-slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .speed-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .speed-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      font-weight: 600;
    }

    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 25px;
      overflow: auto;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
    }

    .bottom-bar {
      background: rgba(255, 255, 255, 0.98);
      padding: 20px 25px;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.12);
      border-top: 3px solid #66BB6A;
    }

    .output-title {
      font-size: 17px;
      font-weight: bold;
      color: #2E7D32;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .traversal-sequence {
      font-size: 22px;
      font-weight: bold;
      color: #E91E63;
      text-align: center;
      padding: 18px;
      background: linear-gradient(135deg, #FCE4EC 0%, #F8BBD0 100%);
      border-radius: 12px;
      margin-bottom: 15px;
      border: 3px solid #EC407A;
      min-height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.6;
      max-height: 150px;
      overflow-y: auto;
    }

    .efficiency-box {
      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
      border: 3px solid #66BB6A;
      border-radius: 12px;
      padding: 18px;
      margin-top: 12px;
      box-shadow: 0 3px 12px rgba(102, 187, 106, 0.25);
    }

    .efficiency-box h3 {
      margin: 0 0 10px 0;
      color: #2E7D32;
      font-size: 17px;
      font-weight: 700;
    }

    .efficiency-box p {
      margin: 0;
      font-size: 14px;
      color: #1a1a1a;
      line-height: 1.6;
    }

    .complete-message {
      background: linear-gradient(135deg, #FFF3E0 0%, #FFE0B2 100%);
      border: 3px solid #FFB74D;
      border-radius: 12px;
      padding: 14px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      color: #E65100;
      margin-bottom: 12px;
      box-shadow: 0 3px 12px rgba(255, 152, 0, 0.25);
    }

    .complexity-box {
      background: linear-gradient(135deg, #E1F5FE 0%, #B3E5FC 100%);
      border: 3px solid #29B6F6;
      border-radius: 12px;
      padding: 18px;
      margin-top: 12px;
      box-shadow: 0 3px 12px rgba(41, 182, 246, 0.25);
    }

    .complexity-box h3 {
      margin: 0 0 12px 0;
      color: #01579B;
      font-size: 17px;
      font-weight: 700;
      text-align: center;
    }

    .complexity-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 15px;
    }

    .complexity-item {
      background: white;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .complexity-label {
      font-size: 13px;
      color: #666;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .complexity-value {
      font-size: 22px;
      font-weight: bold;
      color: #01579B;
      font-family: 'Courier New', monospace;
    }

    .graph-container {
      background: white;
      border-radius: 10px;
      padding: 15px;
      margin-top: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .graph-title {
      font-size: 14px;
      font-weight: bold;
      color: #01579B;
      text-align: center;
      margin-bottom: 10px;
    }

    .graph-canvas-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #complexity-graph {
      max-width: 100%;
      height: auto;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body class="h-full">
  <div class="main-container"><!-- LEFT PANEL -->
   <div class="left-panel">
    <h1 id="app-title">BST Traversal Visualizer</h1><!-- Input Section -->
    <div class="section">
     <div class="section-title">
      Build Tree
     </div>
     <div class="input-group"><label class="input-label" id="input-label">Enter node values (comma separated)</label> <input type="text" id="node-input" placeholder="e.g., 25,10,35,5,15,30,40">
     </div><button class="btn btn-build" id="build-btn">Build Tree</button>
    </div><!-- BST Comparison Logic -->
    <div class="section">
     <div class="section-title">
      BST Comparison Logic
     </div>
     <div class="comparison-box" id="comparison-box">
      <div style="color: #666; text-align: center; font-size: 14px;">
       Build a tree to see comparison logic
      </div>
     </div>
    </div><!-- Traversal Selection -->
    <div class="section">
     <div class="section-title">
      Traversal Selection
     </div><button class="btn btn-traversal" id="inorder-btn" disabled><span id="inorder-text">Inorder</span></button> <button class="btn btn-traversal" id="preorder-btn" disabled><span id="preorder-text">Preorder</span></button> <button class="btn btn-traversal" id="postorder-btn" disabled><span id="postorder-text">Postorder</span></button> <button class="btn btn-traversal" id="levelorder-btn" disabled><span id="levelorder-text">Level Order</span></button>
    </div><!-- Automation Controls -->
    <div class="section">
     <div class="section-title">
      Automation Controls
     </div><button class="btn btn-control" id="play-btn" disabled>‚ñ∂Ô∏è <span id="play-text">Play</span></button> <button class="btn btn-control pause" id="pause-btn" disabled>‚è∏ <span id="pause-text">Pause</span></button> <button class="btn btn-control" id="next-btn" disabled>‚è≠ <span id="next-text">Next Step</span></button> <button class="btn btn-control reset" id="reset-btn" disabled>üîÑ <span id="reset-text">Reset</span></button>
     <div class="speed-control"><label class="input-label">Visualization Speed</label> <input type="range" id="speed-slider" class="speed-slider" min="1" max="10" value="5">
      <div class="speed-labels"><span>Slow</span> <span>Fast</span>
      </div>
     </div>
    </div><!-- Algorithm Steps -->
    <div class="section">
     <div class="section-title">
      Algorithm Steps
     </div>
     <div class="algorithm-steps" id="algorithm-steps">
      <div class="step-item">
       Select a traversal method
      </div>
     </div>
    </div><!-- Traversal Rule -->
    <div class="section">
     <div class="section-title">
      Traversal Rule
     </div>
     <div class="traversal-rule-box" id="traversal-rule">
      Select traversal to see rule
     </div>
    </div>
   </div><!-- RIGHT PANEL -->
   <div class="right-panel">
    <div class="canvas-container">
     <canvas id="tree-canvas" width="1400" height="800"></canvas>
    </div><!-- Bottom Bar -->
    <div class="bottom-bar">
     <div id="complete-message"></div>
     <div class="output-title">
      Traversal Order:
     </div>
     <div class="traversal-sequence" id="traversal-output">
      Build a tree to start
     </div>
     <div id="efficiency-display"></div>
     <div id="complexity-display"></div>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      app_title: "BST Traversal Visualizer",
      input_label: "Enter node values (comma separated)",
      build_button: "Build Tree",
      play_button: "Play",
      pause_button: "Pause",
      next_button: "Next Step",
      reset_button: "Reset",
      inorder_label: "Inorder",
      preorder_label: "Preorder",
      postorder_label: "Postorder",
      levelorder_label: "Level Order",
      background_color: "#87CEEB",
      panel_color: "#FFFFFF",
      node_root: "#66BB6A",
      node_unvisited: "#C8E6C9",
      node_active: "#FFD700",
      node_visited: "#81C784"
    };

    class TreeNode {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
      }
    }

    class BSTVisualizer {
      constructor() {
        this.root = null;
        this.canvas = document.getElementById('tree-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.nodeRadius = 38;
        this.levelHeight = 120;
        this.currentTraversal = null;
        this.traversalSequence = [];
        this.animationIndex = 0;
        this.visitedNodes = new Set();
        this.currentNode = null;
        this.isPlaying = false;
        this.animationSpeed = 1000;
        this.currentStep = 0;
        this.currentRulePart = -1;
        this.animationInterval = null;
      }

      insert(value) {
        if (this.root === null) {
          this.root = new TreeNode(value);
          this.showComparison(`Inserting ${value}`, 'Root position', `Insert ${value} as root node`);
        } else {
          this.insertNode(this.root, value);
        }
      }

      insertWithAnimation(value, callback) {
        if (this.root === null) {
          this.root = new TreeNode(value);
          this.showComparison(`Inserting ${value}`, 'Root position', `‚úÖ Inserted ${value} as root node`);
          if (callback) callback();
        } else {
          this.insertNodeWithAnimation(this.root, value, callback);
        }
      }

      insertNodeWithAnimation(node, value, callback) {
        const isLessThan = value < node.value;
        const comparison = isLessThan ? 'Yes ÔøΩÔøΩ Go Left' : 'No ‚Üí Go Right';
        const direction = isLessThan ? 'left' : 'right';
        
        this.showComparison(
          `Is ${value} < ${node.value}?`,
          comparison,
          `Decision: Insert on ${direction === 'left' ? 'Left' : 'Right'} Subtree`
        );

        if (isLessThan) {
          if (node.left === null) {
            setTimeout(() => {
              node.left = new TreeNode(value);
              this.showComparison(
                `Inserting ${value}`,
                `Left child of ${node.value}`,
                `‚úÖ Node ${value} inserted successfully!`
              );
              if (callback) callback();
            }, 600);
          } else {
            setTimeout(() => {
              this.insertNodeWithAnimation(node.left, value, callback);
            }, 600);
          }
        } else {
          if (node.right === null) {
            setTimeout(() => {
              node.right = new TreeNode(value);
              this.showComparison(
                `Inserting ${value}`,
                `Right child of ${node.value}`,
                `‚úÖ Node ${value} inserted successfully!`
              );
              if (callback) callback();
            }, 600);
          } else {
            setTimeout(() => {
              this.insertNodeWithAnimation(node.right, value, callback);
            }, 600);
          }
        }
      }

      insertNode(node, value) {
        const isLessThan = value < node.value;
        const comparison = isLessThan ? 'Yes ‚Üí Go Left' : 'No ‚Üí Go Right';
        const direction = isLessThan ? 'left' : 'right';
        
        this.showComparison(
          `Is ${value} < ${node.value}?`,
          comparison,
          `Decision: Insert on ${direction === 'left' ? 'Left' : 'Right'} Subtree`
        );

        if (isLessThan) {
          if (node.left === null) {
            node.left = new TreeNode(value);
          } else {
            this.insertNode(node.left, value);
          }
        } else {
          if (node.right === null) {
            node.right = new TreeNode(value);
          } else {
            this.insertNode(node.right, value);
          }
        }
      }

      showComparison(question, answer, decision) {
        const box = document.getElementById('comparison-box');
        box.innerHTML = `
          <div class="question">${question}</div>
          <div class="answer">${answer}</div>
          <div class="decision">${decision}</div>
        `;
      }

      calculatePositions() {
        if (!this.root) return;
        const width = this.canvas.width;
        this.calculateNodePositions(this.root, width / 2, 80, width / 4);
      }

      calculateNodePositions(node, x, y, offset) {
        if (!node) return;
        node.x = x;
        node.y = y;
        if (node.left) {
          this.calculateNodePositions(node.left, x - offset, y + this.levelHeight, offset / 2);
        }
        if (node.right) {
          this.calculateNodePositions(node.right, x + offset, y + this.levelHeight, offset / 2);
        }
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.root) {
          this.drawConnections(this.root);
          this.drawNodes(this.root);
        }
      }

      drawConnections(node) {
        if (!node) return;

        this.ctx.strokeStyle = '#2E7D32';
        this.ctx.lineWidth = 5;

        if (node.left) {
          this.ctx.beginPath();
          this.ctx.moveTo(node.x, node.y);
          this.ctx.lineTo(node.left.x, node.left.y);
          this.ctx.stroke();
          this.drawConnections(node.left);
        }

        if (node.right) {
          this.ctx.beginPath();
          this.ctx.moveTo(node.x, node.y);
          this.ctx.lineTo(node.right.x, node.right.y);
          this.ctx.stroke();
          this.drawConnections(node.right);
        }
      }

      drawNodes(node) {
        if (!node) return;

        if (node.left) this.drawNodes(node.left);
        if (node.right) this.drawNodes(node.right);

        let nodeColor;
        const config = window.elementSdk?.config || defaultConfig;
        
        if (this.currentNode === node) {
          nodeColor = config.node_active || defaultConfig.node_active;
          this.ctx.shadowBlur = 35;
          this.ctx.shadowColor = nodeColor;
        } else if (this.visitedNodes.has(node)) {
          nodeColor = config.node_visited || defaultConfig.node_visited;
          this.ctx.shadowBlur = 15;
          this.ctx.shadowColor = 'rgba(129, 199, 132, 0.6)';
        } else if (node === this.root) {
          nodeColor = config.node_root || defaultConfig.node_root;
        } else {
          nodeColor = config.node_unvisited || defaultConfig.node_unvisited;
        }

        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, this.nodeRadius, 0, Math.PI * 2);
        this.ctx.fillStyle = nodeColor;
        this.ctx.fill();
        this.ctx.lineWidth = 4;
        this.ctx.strokeStyle = '#2E7D32';
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;

        if (this.currentNode === node) {
          this.ctx.font = 'bold 40px Arial';
          this.ctx.fillStyle = '#FFD700';
          this.ctx.textAlign = 'center';
          this.ctx.textBaseline = 'middle';
          this.ctx.shadowBlur = 10;
          this.ctx.shadowColor = '#FFD700';
          this.ctx.fillText('‚òÖ', node.x, node.y - 55);
          this.ctx.shadowBlur = 0;
        }

        this.ctx.fillStyle = 'white';
        this.ctx.font = 'bold 26px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.shadowBlur = 2;
        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillText(node.value, node.x, node.y);
        this.ctx.shadowBlur = 0;
      }

      inorderTraversal(node, result = []) {
        if (node) {
          this.inorderTraversal(node.left, result);
          result.push(node);
          this.inorderTraversal(node.right, result);
        }
        return result;
      }

      preorderTraversal(node, result = []) {
        if (node) {
          result.push(node);
          this.preorderTraversal(node.left, result);
          this.preorderTraversal(node.right, result);
        }
        return result;
      }

      postorderTraversal(node, result = []) {
        if (node) {
          this.postorderTraversal(node.left, result);
          this.postorderTraversal(node.right, result);
          result.push(node);
        }
        return result;
      }

      levelOrderTraversal(node) {
        const result = [];
        if (!node) return result;
        const queue = [node];
        while (queue.length > 0) {
          const current = queue.shift();
          result.push(current);
          if (current.left) queue.push(current.left);
          if (current.right) queue.push(current.right);
        }
        return result;
      }

      startTraversal(type) {
        this.stopAnimation();
        this.currentTraversal = type;
        this.visitedNodes.clear();
        this.currentNode = null;
        this.animationIndex = 0;
        this.currentStep = 0;
        this.currentRulePart = -1;

        switch(type) {
          case 'inorder':
            this.traversalSequence = this.inorderTraversal(this.root);
            break;
          case 'preorder':
            this.traversalSequence = this.preorderTraversal(this.root);
            break;
          case 'postorder':
            this.traversalSequence = this.postorderTraversal(this.root);
            break;
          case 'levelorder':
            this.traversalSequence = this.levelOrderTraversal(this.root);
            break;
        }

        this.updateAlgorithmSteps();
        this.updateTraversalRule();
        document.getElementById('traversal-output').textContent = 'Starting traversal...';
        document.getElementById('efficiency-display').innerHTML = '';
        document.getElementById('complexity-display').innerHTML = '';
        document.getElementById('complete-message').innerHTML = '';
        this.draw();
      }

      updateAlgorithmSteps() {
        const stepsContainer = document.getElementById('algorithm-steps');
        let steps = [];

        switch(this.currentTraversal) {
          case 'inorder':
            steps = ['Start traversal', 'Traverse left subtree', 'Visit root node', 'Traverse right subtree', 'Add node to output'];
            break;
          case 'preorder':
            steps = ['Start traversal', 'Visit root node', 'Traverse left subtree', 'Traverse right subtree', 'Add node to output'];
            break;
          case 'postorder':
            steps = ['Start traversal', 'Traverse left subtree', 'Traverse right subtree', 'Visit root node', 'Add node to output'];
            break;
          case 'levelorder':
            steps = ['Start traversal', 'Visit nodes level by level', 'Move according to rule', 'Process left to right', 'Add node to output'];
            break;
        }

        stepsContainer.innerHTML = steps.map((step, index) => 
          `<div class="step-item ${index === this.currentStep ? 'active' : ''}">${step}</div>`
        ).join('');
      }

      updateTraversalRule() {
        const ruleContainer = document.getElementById('traversal-rule');
        let rule = '';

        switch(this.currentTraversal) {
          case 'inorder':
            rule = `<span class="rule-part ${this.currentRulePart === 0 ? 'active' : ''}">Left</span> | <span class="rule-part ${this.currentRulePart === 1 ? 'active' : ''}">Root</span> | <span class="rule-part ${this.currentRulePart === 2 ? 'active' : ''}">Right</span>`;
            break;
          case 'preorder':
            rule = `<span class="rule-part ${this.currentRulePart === 0 ? 'active' : ''}">Root</span> | <span class="rule-part ${this.currentRulePart === 1 ? 'active' : ''}">Left</span> | <span class="rule-part ${this.currentRulePart === 2 ? 'active' : ''}">Right</span>`;
            break;
          case 'postorder':
            rule = `<span class="rule-part ${this.currentRulePart === 0 ? 'active' : ''}">Left</span> | <span class="rule-part ${this.currentRulePart === 1 ? 'active' : ''}">Right</span> | <span class="rule-part ${this.currentRulePart === 2 ? 'active' : ''}">Root</span>`;
            break;
          case 'levelorder':
            rule = '<span class="rule-part">Level by Level</span> | <span class="rule-part">Left to Right</span>';
            break;
        }

        ruleContainer.innerHTML = rule;
      }

      animateStep() {
        if (this.animationIndex < this.traversalSequence.length) {
          this.currentNode = this.traversalSequence[this.animationIndex];
          this.visitedNodes.add(this.currentNode);
          
          this.currentStep = Math.min(this.animationIndex % 4 + 1, 4);
          this.currentRulePart = this.animationIndex % 3;
          
          this.updateAlgorithmSteps();
          this.updateTraversalRule();
          this.draw();
          
          const sequence = Array.from(this.visitedNodes).map(n => n.value).join(' ‚Üí ');
          document.getElementById('traversal-output').textContent = sequence;
          
          this.animationIndex++;
          
          if (this.animationIndex >= this.traversalSequence.length) {
            this.completeTraversal();
          }
        }
      }

      completeTraversal() {
        this.isPlaying = false;
        this.stopAnimation();
        
        document.getElementById('complete-message').innerHTML = `
          <div class="complete-message">‚ú® Traversal Complete ‚ú®</div>
        `;

        let efficientTraversal = 'Inorder';
        let explanation = 'Inorder traversal is efficient for a Binary Search Tree because it outputs values in sorted order.';

        if (this.currentTraversal === 'levelorder') {
          efficientTraversal = 'Level Order';
          explanation = 'Level Order traversal is efficient for breadth-first operations and finding shortest paths in trees.';
        }

        document.getElementById('efficiency-display').innerHTML = `
          <div class="efficiency-box">
            <h3>‚ú® Most Efficient Traversal for This Tree: ${efficientTraversal}</h3>
            <p><strong>Explanation:</strong> ${explanation}</p>
          </div>
        `;

        this.displayTimeComplexity();

        document.getElementById('play-btn').disabled = true;
        document.getElementById('pause-btn').disabled = true;
        document.getElementById('next-btn').disabled = true;
      }

      displayTimeComplexity() {
        const n = this.traversalSequence.length;
        const timeComplexity = 'O(n)';
        
        // Check if tree is balanced
        const isBalanced = this.checkBalanced(this.root);
        const height = this.getHeight(this.root);
        
        let spaceComplexity, spaceExplanation;
        
        if (this.currentTraversal === 'levelorder') {
          // Level order uses queue, max width at any level
          spaceComplexity = 'O(w)';
          spaceExplanation = 'where w is max width';
        } else {
          // Recursive traversals use call stack
          if (isBalanced) {
            spaceComplexity = 'O(log n)';
            spaceExplanation = 'balanced tree - log n height';
          } else {
            spaceComplexity = 'O(n)';
            spaceExplanation = 'skewed tree - linear height';
          }
        }

        const balanceStatus = isBalanced ? '‚úÖ Balanced' : '‚ö†Ô∏è Unbalanced';
        const balanceColor = isBalanced ? '#4CAF50' : '#FF9800';

        document.getElementById('complexity-display').innerHTML = `
          <div class="complexity-box">
            <h3>‚è±Ô∏è Time & Space Complexity Analysis</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <div class="complexity-label">Time Complexity</div>
                <div class="complexity-value">${timeComplexity}</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Space Complexity</div>
                <div class="complexity-value">${spaceComplexity}</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Tree Height</div>
                <div class="complexity-value">${height}</div>
              </div>
              <div class="complexity-item">
                <div class="complexity-label">Balance Status</div>
                <div class="complexity-value" style="color: ${balanceColor}; font-size: 18px;">${balanceStatus}</div>
              </div>
            </div>
            <div style="text-align: center; font-size: 13px; color: #01579B; margin-top: 8px;">
              <strong>Time:</strong> All traversals visit each node exactly once - ${timeComplexity}<br>
              <strong>Space:</strong> ${spaceComplexity} (${spaceExplanation})<br>
              <strong>Nodes:</strong> ${n} total nodes in tree
            </div>
            <div class="graph-container">
              <div class="graph-title">Time Complexity Growth: O(n)</div>
              <div class="graph-canvas-wrapper">
                <canvas id="complexity-graph" width="500" height="200"></canvas>
              </div>
            </div>
          </div>
        `;

        this.drawComplexityGraph(n);
      }

      getHeight(node) {
        if (!node) return 0;
        return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
      }

      checkBalanced(node) {
        if (!node) return true;
        
        const leftHeight = this.getHeight(node.left);
        const rightHeight = this.getHeight(node.right);
        
        // Check if current node is balanced and recursively check subtrees
        if (Math.abs(leftHeight - rightHeight) > 1) {
          return false;
        }
        
        return this.checkBalanced(node.left) && this.checkBalanced(node.right);
      }

      drawComplexityGraph(currentN) {
        const canvas = document.getElementById('complexity-graph');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const padding = 50;
        const graphWidth = width - 2 * padding;
        const graphHeight = height - 2 * padding;

        ctx.clearRect(0, 0, width, height);

        // Draw axes
        ctx.strokeStyle = '#424242';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();

        // Labels
        ctx.fillStyle = '#424242';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Input Size (n)', width / 2, height - 10);
        
        ctx.save();
        ctx.translate(15, height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Operations', 0, 0);
        ctx.restore();

        // Generate data points for O(n) linear growth
        const maxN = Math.max(currentN + 5, 20);
        const points = [];
        for (let i = 1; i <= maxN; i++) {
          points.push({ n: i, ops: i });
        }

        // Draw O(n) line
        ctx.strokeStyle = '#29B6F6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        points.forEach((point, index) => {
          const x = padding + (point.n / maxN) * graphWidth;
          const y = height - padding - (point.ops / maxN) * graphHeight;
          
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        // Draw current point
        const currentX = padding + (currentN / maxN) * graphWidth;
        const currentY = height - padding - (currentN / maxN) * graphHeight;
        
        ctx.fillStyle = '#4CAF50';
        ctx.beginPath();
        ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Label current point
        ctx.fillStyle = '#2E7D32';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`n=${currentN}`, currentX + 10, currentY - 10);

        // Draw grid lines
        ctx.strokeStyle = '#E0E0E0';
        ctx.lineWidth = 1;
        const gridLines = 5;
        
        for (let i = 1; i <= gridLines; i++) {
          const y = height - padding - (i / gridLines) * graphHeight;
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(width - padding, y);
          ctx.stroke();
          
          ctx.fillStyle = '#666';
          ctx.font = '10px Arial';
          ctx.textAlign = 'right';
          ctx.fillText(Math.round((i / gridLines) * maxN), padding - 5, y + 3);
        }

        // X-axis labels
        for (let i = 0; i <= 4; i++) {
          const x = padding + (i / 4) * graphWidth;
          const labelValue = Math.round((i / 4) * maxN);
          ctx.fillStyle = '#666';
          ctx.font = '10px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(labelValue, x, height - padding + 15);
        }

        // Legend
        ctx.fillStyle = '#29B6F6';
        ctx.fillRect(width - 120, 20, 20, 3);
        ctx.fillStyle = '#424242';
        ctx.font = '11px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('O(n) Linear', width - 95, 25);
      }

      startAnimation() {
        this.isPlaying = true;
        const speed = document.getElementById('speed-slider').value;
        this.animationSpeed = 2100 - (speed * 180);
        
        this.animationInterval = setInterval(() => {
          if (this.isPlaying) {
            this.animateStep();
          }
        }, this.animationSpeed);
      }

      stopAnimation() {
        this.isPlaying = false;
        if (this.animationInterval) {
          clearInterval(this.animationInterval);
          this.animationInterval = null;
        }
      }

      reset() {
        this.stopAnimation();
        if (this.currentTraversal) {
          this.startTraversal(this.currentTraversal);
        }
        document.getElementById('play-btn').disabled = false;
        document.getElementById('pause-btn').disabled = true;
        document.getElementById('next-btn').disabled = false;
      }
    }

    const visualizer = new BSTVisualizer();

    let buildAnimationInterval = null;
    let buildQueue = [];
    let isBuildingTree = false;

    document.getElementById('build-btn').addEventListener('click', () => {
      const input = document.getElementById('node-input').value;
      const values = input.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
      
      if (values.length === 0) {
        document.getElementById('comparison-box').innerHTML = `
          <div style="color: #E74C3C; font-weight: bold; text-align: center;">‚ö†Ô∏è Please enter valid numbers</div>
        `;
        return;
      }

      if (isBuildingTree) {
        return;
      }

      visualizer.root = null;
      visualizer.visitedNodes.clear();
      visualizer.currentNode = null;
      visualizer.currentTraversal = null;
      buildQueue = [...values];
      isBuildingTree = true;
      
      document.getElementById('build-btn').disabled = true;
      document.getElementById('inorder-btn').disabled = true;
      document.getElementById('preorder-btn').disabled = true;
      document.getElementById('postorder-btn').disabled = true;
      document.getElementById('levelorder-btn').disabled = true;
      document.getElementById('traversal-output').textContent = 'Building tree step by step...';
      document.getElementById('efficiency-display').innerHTML = '';
      document.getElementById('complexity-display').innerHTML = '';
      document.getElementById('complete-message').innerHTML = '';
      document.querySelectorAll('.btn-traversal').forEach(btn => btn.classList.remove('active'));

      buildTreeStepByStep();
    });

    async function buildTreeStepByStep() {
      if (buildQueue.length === 0) {
        isBuildingTree = false;
        document.getElementById('build-btn').disabled = false;
        document.getElementById('inorder-btn').disabled = false;
        document.getElementById('preorder-btn').disabled = false;
        document.getElementById('postorder-btn').disabled = false;
        document.getElementById('levelorder-btn').disabled = false;
        document.getElementById('traversal-output').textContent = 'Tree built successfully! Select a traversal method';
        document.getElementById('comparison-box').innerHTML = `
          <div style="color: #4CAF50; font-weight: bold; text-align: center; font-size: 16px;">
            ‚úÖ Tree Construction Complete!<br>
            <span style="font-size: 14px; color: #666;">All nodes inserted successfully</span>
          </div>
        `;
        return;
      }

      const value = buildQueue.shift();
      
      await new Promise(resolve => {
        visualizer.insertWithAnimation(value, () => {
          visualizer.calculatePositions();
          visualizer.draw();
          setTimeout(() => {
            resolve();
          }, 800);
        });
      });

      setTimeout(() => {
        buildTreeStepByStep();
      }, 1200);
    }

    function setupTraversalButton(buttonId, traversalType) {
      document.getElementById(buttonId).addEventListener('click', () => {
        document.querySelectorAll('.btn-traversal').forEach(btn => btn.classList.remove('active'));
        document.getElementById(buttonId).classList.add('active');
        
        visualizer.startTraversal(traversalType);
        document.getElementById('play-btn').disabled = false;
        document.getElementById('pause-btn').disabled = true;
        document.getElementById('next-btn').disabled = false;
        document.getElementById('reset-btn').disabled = false;
      });
    }

    setupTraversalButton('inorder-btn', 'inorder');
    setupTraversalButton('preorder-btn', 'preorder');
    setupTraversalButton('postorder-btn', 'postorder');
    setupTraversalButton('levelorder-btn', 'levelorder');

    document.getElementById('play-btn').addEventListener('click', () => {
      visualizer.startAnimation();
      document.getElementById('play-btn').disabled = true;
      document.getElementById('pause-btn').disabled = false;
    });

    document.getElementById('pause-btn').addEventListener('click', () => {
      visualizer.stopAnimation();
      document.getElementById('play-btn').disabled = false;
      document.getElementById('pause-btn').disabled = true;
    });

    document.getElementById('next-btn').addEventListener('click', () => {
      visualizer.animateStep();
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      visualizer.reset();
    });

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange: async (config) => {
          document.getElementById('app-title').textContent = config.app_title || defaultConfig.app_title;
          document.getElementById('input-label').textContent = config.input_label || defaultConfig.input_label;
          document.getElementById('build-btn').textContent = config.build_button || defaultConfig.build_button;
          document.getElementById('play-text').textContent = config.play_button || defaultConfig.play_button;
          document.getElementById('pause-text').textContent = config.pause_button || defaultConfig.pause_button;
          document.getElementById('next-text').textContent = config.next_button || defaultConfig.next_button;
          document.getElementById('reset-text').textContent = config.reset_button || defaultConfig.reset_button;
          document.getElementById('inorder-text').textContent = config.inorder_label || defaultConfig.inorder_label;
          document.getElementById('preorder-text').textContent = config.preorder_label || defaultConfig.preorder_label;
          document.getElementById('postorder-text').textContent = config.postorder_label || defaultConfig.postorder_label;
          document.getElementById('levelorder-text').textContent = config.levelorder_label || defaultConfig.levelorder_label;
          
          const bgColor = config.background_color || defaultConfig.background_color;
          document.querySelector('.main-container').style.background = bgColor;
          document.querySelector('.right-panel').style.background = bgColor;
          
          visualizer.draw();
        },
        mapToCapabilities: (config) => ({
          recolorables: [
            {
              get: () => config.background_color || defaultConfig.background_color,
              set: (value) => {
                config.background_color = value;
                window.elementSdk.setConfig({ background_color: value });
              }
            },
            {
              get: () => config.panel_color || defaultConfig.panel_color,
              set: (value) => {
                config.panel_color = value;
                window.elementSdk.setConfig({ panel_color: value });
              }
            },
            {
              get: () => config.node_root || defaultConfig.node_root,
              set: (value) => {
                config.node_root = value;
                window.elementSdk.setConfig({ node_root: value });
              }
            },
            {
              get: () => config.node_unvisited || defaultConfig.node_unvisited,
              set: (value) => {
                config.node_unvisited = value;
                window.elementSdk.setConfig({ node_unvisited: value });
              }
            },
            {
              get: () => config.node_active || defaultConfig.node_active,
              set: (value) => {
                config.node_active = value;
                window.elementSdk.setConfig({ node_active: value });
              }
            }
          ],
          borderables: [],
          fontEditable: undefined,
          fontSizeable: undefined
        }),
        mapToEditPanelValues: (config) => new Map([
          ["app_title", config.app_title || defaultConfig.app_title],
          ["input_label", config.input_label || defaultConfig.input_label],
          ["build_button", config.build_button || defaultConfig.build_button],
          ["play_button", config.play_button || defaultConfig.play_button],
          ["pause_button", config.pause_button || defaultConfig.pause_button],
          ["next_button", config.next_button || defaultConfig.next_button],
          ["reset_button", config.reset_button || defaultConfig.reset_button],
          ["inorder_label", config.inorder_label || defaultConfig.inorder_label],
          ["preorder_label", config.preorder_label || defaultConfig.preorder_label],
          ["postorder_label", config.postorder_label || defaultConfig.postorder_label],
          ["levelorder_label", config.levelorder_label || defaultConfig.levelorder_label]
        ])
      });
    }
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9b25bf5556153e1c',t:'MTc2NjQ3MDc2Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>